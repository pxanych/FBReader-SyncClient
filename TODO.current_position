! Всё что написано в этом документе, относится только к синхронизации текущей позиции в книге.

----------------------------------------------------------------

Что нужно плагину от FBReader
- сообщения об открытии книги / уходе в background
	1) title
	2) author
	3) filename
	4) text_position

----------------------------------------------------------------

Данные на сервере: 
	- таблица user:
		1) user_id
		2) google_identifier (OpenID)
		3) signature
		
	- таблица book со следующими полями:
		1) book_id
		2) user_id (foreign key из таблицы user)
		3) book_hash
		4) title
		5) author
		6) current_text_position
		7) update_timestamp
		
Данные плагина:
	- свои Google OpenID
	- Signature
	- список books (в каждом элементе списка хранится):
		1) book_hash (может быть пустым, если ещё не посчитан)
		2) title
		3) author
		4) filename
		5) local_text_position (на момент закрытия книги/остановки FBReader)
		6) local_timestamp (время, когда плагином было получено значение text_position)
	- список to_synchronize из ссылок на элементы books, которые надо отправить на сервер при следующем scheduled_update
	- флаг last_sync_failed (выставляется, если при открытии книги не удалось синхронизироваться)

----------------------------------------------------------------

server-->client:
Условия начала server-->client синхронизации:
	при открытии книги
	  
Клиент отправит серверу запрос на получение текущей позиции в книге с параметрами ID, title, author, hash
	1) Сервер отправит клиенту server_text_position и server_timestamp:
		(local_timestamp < server_timestamp) && (current_text_position < server_text_position):
			если last_sync_failed == true - спросим у пользователя, выставить ли серверную text_position, в противном случае просто выставляем новую позицию. 
	2) Если на сервере в таблице book не окажется строки с таким значением title, author и hash - сервер вернёт пустой ответ, 
	   а плагин не будет предпринимать каких-либо автоматических действий по server-->client синхронизации до следующего открытия книги.
	3) При большой задержке ответа сервера (или отсутствии сети) плагин проверит свой список books на наличие local_text_position для открываемой книги и,
	   если таковая найдётся - выставит новую позицию.
	   Также плагин запомнит выставленную text_position и установит флаг last_sync_failed.

----------------------------------------------------------------

client-->server:
	1) При закрытии книги/уходе FBReader в backgroung плагин получает от FBReader информацию о
	   title, author и text_position, генерирует timestamp, а затем сохраняет всё  в свой список books.
	2) Также клиент отправляет серверу запрос на обновление таблицы book с параметрами id, title, author, [hash,] text_position и timestamp

----------------------------------------------------------------

scheduled_update:

	1) По таймауту плагин запрашивает у сервера список текущих позиций для своего id
		*плагин может явно указать title, author, hash книг, для которых сервер должен выслать text_position
	2) Сервер отправит плагину и список из (title, author, hash, current_text_position, server_timestamp) для указанных плагином книг
		*если плагин явно не указал список книг, сервер отправит ему данные для N книг с самым большим timestamp 
	3) Плагин обновит свой список books в соответствии с timestamp'ами
	4) Если у плагина в списке to_synchronize есть какие-либо элементы:
		4.1) он отправит их серверу (title, author, hash, text_position, timestamp)
		4.2) Сервер обновляет таблицу book в соответствии с timestamp'ами и подтверждает успешное получение информации
		4.3) Плагин очищает свой список to_synchronize, если сервер сообщил об успешной синхронизации
		
----------------------------------------------------------------

Как оно выглядит сейчас:
1) при уходе FBReader в background - текущая позиция отправляется на сервер
2) когда FBReader переходит в foreground - при необходимости создаём ApiClientImplementation, FBSyncPositionsService и загружаем с сервера позицию.
	* если серверная позиция больше нашей - выставляем её.
	
В 2) есть недостаток: т.к. обмен информацией с сервером занимает какое-то время (через Edge - до нескольких секунд), плагин может выставить позицию не сразу.
Поэтому и хочется что-то показывать пользователю всё это время, чтобы перелистывание страницы не становилось неожиданностью. 
		